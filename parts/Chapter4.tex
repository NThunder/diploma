\section{Описание практической части}
\label{sec:Chapter4} \index{Chapter4}

В данном разделе представлено частичное описание программной реализации исследования, включая выбор инструментов разработки и архитектуру кода.

\begin{itemize}
    \item \textbf{Инструменты разработки:}
    
    Для реализации и исследования были выбраны следующие инструменты:

    Язык программирования: Python 
    
    Библиотеки:

    \begin{itemize}
        \item PyTorch: Фреймворк глубокого обучения, используемый для создания, обучения и оценки нейронных сетей. Обеспечивает автоматическое дифференцирование, работу с тензорами и GPU-ускорение.
        \item OpenCV (cv2): Библиотека компьютерного зрения, применяемая для загрузки, предобработки и манипуляции с изображениями.
        \item NumPy: Библиотека для научных вычислений, предоставляющая функции для работы с многомерными массивами, линейной алгеброй и математическими операциями.
    \end{itemize}
    Выбор Python обусловлен его простотой, читаемостью и широкой распространенностью в сообществе машинного обучения. PyTorch предоставляет гибкий и эффективный фреймворк для работы с нейронными сетями, а OpenCV и NumPy —  необходимые инструменты для обработки изображений и численных данных. 


    \item \textbf{Оптимизатор и планировщик скорости обучения}

    В  качестве  оптимизатора  использовался  алгоритм  AdamW.  

    Параметры  оптимизатора:  
    \begin{itemize}
        \item Скорость  обучения  (\(lr\)):  0.001
        \item Коэффициенты  экспоненциального  усреднения  для  моментов  градиента  (\(\beta1\),  \(\beta2\)):  0.9  и  0.999  соответственно 
        \item Коэффициент  затухания  весов  (weight\_decay):  0.01
    \end{itemize}
    Для  планирования  скорости  обучения  применялся  метод  MultiStepLR,  который  позволяет  уменьшать  скорость  обучения  в  определенные  моменты  времени.  

    В  качестве  параметров  планировщика  использовались: 
    \begin{itemize}
        \item Множитель  скорости  обучения  (\(\gamma\)):  0.1
        \item Эпохи,  на  которых  происходит  уменьшение  скорости  обучения:  40  и  55
    \end{itemize}

    \item \textbf{Вычислительные ресурсы:}

    Для проведения экспериментов и обучения моделей использовалось следующее аппаратное обеспечение:

    Графический процессор: NVIDIA GeForce RTX 4060 Ti. Объём видеопамяти: 16 ГБ.

    Процесс обучения моделей сходился  приблизительно за 4 дня (120 эпох) на указанном оборудовании. Во время обучения каждая модель занимала около 14 Гб видеопамяти. 


    \item  \textbf{Архитектура кода:}

    \begin{itemize}

        \item  \textbf{Преобразование изображения в набор патчей}

        Для преобразования входного изображения в набор патчей и их встраивания в пространство признаков использовался слой нейронной сети PatchEmbed.
        
        \textbf{Принцип работы:}
        
        \begin{enumerate}
            \item \textbf{Инициализация слоя:}
                \begin{itemize}
                    \item Принимает параметры, определяющие размер изображения, размер патча, количество входных каналов, размерность пространства признаков.
                    \item Вычисляет размер сетки патчей и общее количество патчей.
                    \item Создает сверточный слой, который отвечает за извлечение патчей и формирование их представлений.
                \end{itemize}
            \item \textbf{Прямой проход (forward):}
                \begin{itemize}
                    \item Принимает на вход батч изображений.
                    \item Дополняет изображение по краям (padding), чтобы его размер точно делился на размер патча.
                    \item Применяет сверточный слой к входному изображению. Сверточный слой выполняет одновременно две функции:
                        \begin{itemize}
                            \item Делит изображение на патчи с помощью заданного размера ядра.
                            \item Проецирует каждый патч в пространство признаков заданной размерности.
                        \end{itemize}
                    \item Возвращает тензор, содержащий представления всех патчей входного изображения.
                \end{itemize}
        \end{enumerate}
        
        В итоге, слой PatchEmbed преобразует входное изображение в последовательность векторов-признаков, где каждый вектор представляет собой один патч изображения. 

        \item  \textbf{Случайное маскирование патчей (Random Masking)}

            Для  реализации  стратегии  маскирования  патчей  используется  функция random\_masking. 
            
            \textbf{Принцип работы:}
            
            \begin{enumerate}
                \item \textbf{Инициализация:}
                    \begin{itemize}
                        \item Принимает на вход тензор патчей изображения \(x\) размерности \((N, L, D)\), где: 
                            \begin{itemize}
                                \item \(N\) - размер батча,
                                \item \(L\) - количество патчей в последовательности,
                                \item \(D\) -  размерность  вектора-признака  патча.
                            \end{itemize}
                        \item  Принимает  на  вход  коэффициент  маскирования,  который  определяет  долю  патчей,  подлежащих  маскированию.
                        \item Вычисляет количество патчей, которые останутся не замаскированными  (\(len\_keep\)).
                        \item Генерирует тензор случайных чисел той же размерности, что и \(x\),  значения  которого  распределены  равномерно  в  интервале  \(0, 1\).
                    \end{itemize}
            
                \item \textbf{Маскирование:}
                    \begin{itemize}
                        \item Сортирует  случайные  числа в  порядке  возрастания  отдельно  для  каждого  изображения  в  батче  с  помощью 
                        
                        \(torch.argsort\).
                        \item Оставляет  в  качестве  не  замаскированных  патчей  \(len\_keep\)  патчей,  соответствующих  наименьшим  случайным  числам.
                        \item Формирует  тензор  маски,  где  \(0\)  соответствует  не  замаскированному  патчу,  а  \(1\)  -  замаскированному.
                    \end{itemize}
            
                \item \textbf{Результат:}
                \begin{itemize}
                    \item Возвращает  тензор  с  замаскированными  патчами и тензор  маски.
                \end{itemize}
            \end{enumerate}
        
            Таким  образом,  функция  random\_masking  случайным  образом  выбирает  и  маскирует  определенную  долю  патчей  входного  изображения.
    
    \end{itemize}

\end{itemize}

\newpage
